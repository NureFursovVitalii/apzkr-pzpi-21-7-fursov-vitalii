Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління спортивними організаціями

Студент гр. ПЗПІ-21-7             _____________ Фурсов В.М.
(підпис)
Керівник роботи                       ___________________ ст.викл. Сокорчук І.П.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія: 				        ___________________ доц. Лещинський В.О.
(підпис)
___________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Аркуш завдання


Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії______
Спеціальність 121 – Інженерія програмного забезпечення__________
Курс ___3___ Семестр ____________6__________________________
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
Фурсову Віталію Миколайовичу
1. Тема проєкту: Програмна система для управління спортивними організаціями
2. Термін узгодження завдання курсової роботи «13» березня 2024 р.
3. Термін здачі студентом закінченої роботи «8» червня 2024 р.
4. Вихідні дані до проєкту: Програмна система для управління спортивними організаціями дозволить спростити організацію спортивних змагань, підвищити якість і ефективність тренування команд, а також вести статистику успішності команд.
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): 
UML діаграма розгортання, UML діаграма діяльності, UML діаграма прецедентів, ER-діаграма
КАЛЕНДАРНИЙ ПЛАН


№
Назва етапів курсової роботи
Термін виконання етапів
Примітка
1
Функціональна специфікація програмного проєкту
23.03.2024
виконано
2
Проектування програмного проєкту
31.03.2024
виконано
3
Кодування програмного проєкту
15.05.2024
виконано
4
Оформлення пояснювальної записки
01.06.2024
виконано
5
Захист курсової роботи
08.06.2024
виконано



Дата видачі теми проєкту «4» березня 2024 р.

Керівник				______ ст. викл. Сокорчук І. П.
                                                   (підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-7                     		___               Фурсов В.М.
                                                   		(підпис)
РЕФЕРАТ

Пояснювальна записка до курсової роботи: 53 с., 11 рис., 3 табл., 2
додатки, 6 джерел.
ТРЕНУВАННЯ, РОЗКЛАД, КАЛЕНДАР, ПУЛЬС, ОРГАНІЗАЦІЯ, ЗМАГАННЯ, СПОРТСМЕН.

Предметна галузь, що була досліджена в ході виконання курсової роботи - це спортивна індустрія, управління спортивними організаціями та оптимізація процесу тренування спортсменів.
Метою виконання курсової роботи є розробка програмної системи, яка відстежує фізичні показники спортсменів під час занять спортом і використовує отримані дані для ефективного планування розкладу тренувань, веде облік спортивних заходів, зберігає інформацію про тренування, спортивні змагання, матчі, спортивні команди.
Програмна система базується на мові програмування Python, зокрема технології Django для серверної частини, а також JavaScript, HTML та CSS для клієнтської частини. Впровадження датчика вимірювання пульса реалізовано за допомогою онлайн-симулятора мікроконтролерів Wokwi на мові програмування C++. В якості СУБД для проекту було обрано PostgreSQL.
У результаті роботи було здійснено програмну реалізацію системи організації спортивних заходів та управління спортивними командами. Програмна система складається з веб-додатку, серверної частини та смарт-пристрою, що забезпечують комплексне управління спортивними заходами та ефективний моніторинг спортивних показників.
ЗМІСТ


Вступ………………………………………………………………………………….7 
1 Аналіз та концептуальне моделювання предметної області…………………….8
1.1 Бізнес-вимоги…………………………………………………………………….8
1.1.1 Бізнес можливості……………………………………………………………8
1.1.2 Бізнес-цілі та критерії успіху…………………………………………………9
1.1.3 Потреби клієнтів або ринку…………………………………………………...9
1.1.4 Бізнес-ризики…………………………………………………………………10
1.2 Концепція рішення……………………………………………………………11
1.2.1 Окреслення концепції………………………………………………...………11
1.2.2 Головна функціональність…………………………………………………11
1.2.3 Припущення та залежності…………………………………………………..12
1.3 Рамки та обмеження проекту…………………………………………………..13
1.3.1 Рамки первинного випуску…………………………………………………..13
1.3.2 Рамки наступних випусків…………………………………………………...14 
1.3.3 Обмеження та винятки……………………………………………………….14
1.4 Бізнес-контекст…………………………………………………………………15
1.4.1 Профілі зацікавлених сторін…………………………………………………15
1.4.2 Пріоритети проекту…………………………………………………………..16
1.4.3 Робоче середовище…………………………………………………………...18
2 Проектування та програмна реалізація серверної частини додатку…………..19
2.1 Проектування серверної частини програмної системи ……………………19
2.2 Інженерні рішення……………………………………………………………23
2.2.1 Використані технології……………………………………………………….23
2.2.2 Структура проекту……………………………………………………………24
2.2.3 Реалізація REST API………………………………………………………….25
2.2.4 Опис реалізації функції для рекомендації режиму тренувань…………….28
2.2.5 Реалізація функції створення резервної копії бази даних………………….29
3 Проектування та програмна реалізація IoT частини програмної системи……31
3.1 Моделювання IoT-частини програмної системи……………………………...31
3.2 Інженерні рішення…………………………………………………...…………32
3.2.1 Використані технології………………………………………….……………32
3.2.2 Архітектурні рішення………………………………………………………...34
3.3 Взаємодії в системі……………………………………………………………..35
4 Проектування та програмна реалізація клієнтської частини програмної системи.……………………………………………………………………………..36
4.1 Структура клієнтської частини програмної системи………………………36
4.2 Діяльність веб-клієнту програмної системи………………………………….37
4.3 Стани клієнтської частини програмної системи……………………………..37
4.4 Функція конвертації ваги та росту…………………………………………….38
Висновки…………………………………………………………………………….39
Перелік джерел посилання………………………………………………………...40
Додаток А…………………………………………………………………………...41
Додаток Б……………………………………………………………………………53

ВСТУП


З самого початку своєї історії люди організовували і приймали участь в спортивних змаганнях. Вони мотивують спортсменів до безперервного розвитку своєї майстерності, зміцнення психічного та фізичного здоров’я, виховують дисципліну і покращують міжнародні зв’язки. Стрімка цифровізація, яка відбувається протягом останніх десятиліть, пропонує нові методи рішення задач у всіх сферах людської діяльності, і управління спортивними організаціями не є виключенням. Серед спортивних команд, спортсменів і тренерів існує попит на сучасне і технологічне рішення для організації процесів керування спортивними організаціями.
Розроблювана програмна система спрямована на спрощення процесу обліку і аналітики показників спортсменів, підвищення рівню организованості і ефективності тренувань, а також ведення статистики успішності спортсменів на змаганнях.
Така програмна система стане логічним розвитком інструментів для організації і обліку в галузі спортивних заходів, а також органічно доповнить існуючі методики тренувань спортсменів і управління спортивними організаціями.
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості


Проект орієнтується на ринок програмних систем для управління спортивними заходами, організації тренувань та ведення статистики спортивних досягнень. Проект є перспективним, бо у обраній предметній галузі є зростаючий попит на цифрові рішення, зацікавленість людей у здоровому способі життя і спорті, а також потенціал для інновацій та впровадження нових функцій, яких немає у програм-аналогів.
Серед конкурентів для розроблюваної програмної системи можна виділити такі застосунки, як Sportlyzer і TeamBuildr. Основним функціоналом Sportlyzer є планування тренувань, аналіз результатів і управління фінансами, що надає широкий інструментарій для організації діяльності спортивної організації, однак слід зазначити, що додаток Sportlyzer був розроблений ще у 2010 році, тому він не враховує велику кількість сучасних практик дизайну користувальницьких інтерфейсів, а також не підтримує інтеграцію з іншими додатками або фітнес-браслетами.
Іншим конкурентом проекту є TeamBuildr - це додаток, перевагами якого є можливість створення тренувальних програм, наявність мобільного додатку і можливість інтеграції з фітнес-браслетами для відстеження фізичних показників спортсменів під час тренувань. Недоліками цього додатку є доволі мала кількість підтримуваних видів спорту, для яких програма може надавати аналіз, а також спеціалізація додатку на індивідуальних тренуваннях, яка зменшує потенціал використання програми спортсменами, які займаються командними видами спорту.
Монетизацію проекту можна реалізувати шляхом впровадження кількох рівнів платної підписки для організацій аматорського, напівпрофесійного або професійного рівня, кожна з яких включала б різний набір інструментів для ведення статистики і аналізу, який би відповідав потребам різних груп користувачів.


1.1.2	Бізнес-цілі та критерії успіху


Проект намагається досягти наступних бізнес-цілей:
BO-1: Систематизувати і зробити зручнішим ведення статистики успішності спортивних організацій на змаганнях;
BO-2: Надати спортивним командам інструментарій для організації ефективних тренувань;
BO-3: Надати тренерам і спортсменам інструменти для аналітики проведених тренувань.
Критеріями успіху вважається досягнення проектом таких цілей:
SC-1: Використання системи 20000 спортивних організацій;
SC-2: Покращення результативності организацій, які використовують додаток, на 20% за перший рік використання програми;
SC-3: Використання програмної системи спортивними організаціями, які приймають участь в змаганнях найвищого рівня, таких як ФІФА, НБА, НФЛ тощо.


1.1.3	Потреби клієнтів або ринку


Спортивні організації з різних країн, рівнів майстерності, вікових груп мають потребу в зручній, надійній програмній системі, яка надасть їм інструментарій для обліку, організації та аналітики проведених тренувань і спортивних змагань. Розроблювана програмна система допоможе спортсменам зі всього світу розвивати свою майстерність і досягати кращих результатів. Вона спрощує ведення статистики та оцінку успішності спортсменів, підвищує рівень організації тренувальних процесів і сприяє досягненню кращих результатів у спортивній діяльності.


1.1.4	Бізнес-ризики


Розробка програмної системи для управління спортивними організаціями несе наступні бізнес-ризики:
-	можливість витоку особистих даних користувачів, який завдасть шкоду репутації компанії;
-	проблеми з інтеграцією необхідних для роботи повного функціоналу програмної системи пристроїв, таких як фітнес-браслети або розумні годинники можуть значно знизити конкурентоспроможність додатку;
-	непередбачувані відмови серверів або проблеми з доступом до мережі Інтернет можуть спричинити збої в роботі системи, що призведе до недоступності для користувачів або втрати даних;
-	некоректний підрахунок датчиками фізичних показників спортсменів, таких як пульс, можуть спричинити формування невірного уявлення про його стан і, як наслідок, завдати шкоди здоров'ю спортсмена, тому слід вжити додаткових заходів для контролю стану спортсменів і створення безпечних умов під час тренувань.
1.2	Концепція рішення
1.2.1	Окреслення концепції


Проект буде реалізовано у вигляді програмної системи, яка складатиметься з веб-додатка і мобільного застосунку. Основна мета програмної системи - надати користувачам зручний інструментарій для ведення обліку спортивних змагань, організації тренувального процесу і спостереження за фізичним станом спортсменів. Додаток дозволить переглядати і змінювати інформацію про матчі, команди, спортсменів, проведені тренування, збирати статистику результативності команд, планувати майбутні тренування та відстежувати фізичні показники спортсменів, такі як пульс, і на основі їх робити рекомендації для майбутніх тренувань. Таким чином, створена програмна система допоможе спростити керування спортивними організаціями і дозволить більш ефективно проводити тренування спортсменів.


1.2.2	Головна функціональність


Основні функції додатку, доступні користувачам:
MF-1: Реєстрація та авторизація в системі: користувачі можуть створити обліковий запис і авторизуватися в системі;
MF-2: Перегляд змагань: користувачі можуть переглянути змагання, розклад матчів, результати і статистику по матчам, які вже відбулися;
MF-3: Перегляд результатів тренувань: користувачі можуть переглянути дату й час, коли відбулося тренування, його тривалість, тип та фізичні показники під час тренування;
MF-4: Формування рекомендацій до тренувань: на основі фізичних показників спортсменів під час тренувань для них формуються рекомендації для підвищення ефективності тренувань;
Тренерам доступні такі функції програмної системи:
MF-5: Створення нових тренувань: тренер може назначити нове тренування, вказавши його дату і час, тип і призначити його команді.


1.2.3	Припущення та залежності


В ході проектування системи і формування концепції проекту були зроблені наступні припущення:
-	за станом здоров'я спортсменів під час тренувань додатково слідкуватимуть лікарі, усі зміни навантажень відповідно до рекомендацій програмної системи будуть попередньо обговорені з ними;
-	усі користувачі системи мають ПК та смартфони для взаємодії з програмною системою;
-	усі користувачі мають базові навички роботи з технологіями і зможуть швидко освоїти інтерфейс програмної системи;
-	користувачі правильно носять пристрій для вимірювання фізичних показників для забезпечення точності вимірювання;
-	перед тренуванням користувачі перевіряють пристрої для вимірювання фізичних показників на наявність пошкоджень або збоїв.
У системі існують наступні залежності:
-	для роботи програмної системи необхідне підключення до мережі Інтернет;
-	для зберігання даних, потрібних для роботи системи, необхідна база даних.

1.3	Рамки та обмеження
1.3.1	Рамки первинного випуску


В рамках первинного випуску необхідно реалізувати весь базовий функціонал, необхідний для коректної роботи програмної системи. Нижче наведено перелік функцій серверної частини додатку, потрібних для первинного випуску:
SIR-1: Реєстрація та авторизація користувачів у системі;
SIR-2: Перегляд списку змагань і матчів;
SIR-3: Перегляд та створення нових тренувань;
SIR-4: Підтримка CRUD-операцій;
SIR-5: Обробка даних, переданих IoT-пристроєм, для формування рекомендацій до тренувань;
SIR-6: Створення резервних копій бази даних;
До функцій первинного випуску впровадження IoT-пристрою належать:
SIR-7: Вимірювання і передача на сервер даних про фізичні показники спортсмена;
До функцій первинного випуску клієнтської частини додатку відносяться:
SIR-8: Графічний користувальницький інтерфейс, який забезпечує навігацію і зручну взаємодію з додатком;
SIR-9: Інтернаціоналізація - підтримка різних одиниць вимірювання;
SIR-10: Адміністрування додатка - засоби для адміністраторів, які дозволяють їм керувати сутностями в системі.
1.3.2	Рамки наступних випусків


В ході проектування програмної системи були розглянуті функції, які не є необхідними для роботи додатку, але мають покращити досвід користувачів:
SSR-1: аналітика матчів, визначення помилок, рекомендації для покращення рівня майстерності;
SSR-2: чат з тренером та іншими членами команди;
SSR-3: розширення списку підтримуваних видів спорту.


1.3.3	Обмеження та винятки:


Програмна система має наступні обмеження і винятки:
-	відсутність стабільного підключення до мережі Інтернет може обмежити функціональність програмної системи;
-	датчики, які використовуються для вимірювання фізичних показників спортсменів, мають похибку вимірювань;
-	заплановані змагання можуть бути перенесені їх організаторами.
1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1.1 - Профілі зацікавлених сторін
Зацікавлена сторона
Головна цінність
Ставлення
Головні інтереси
Обмеження
Спортсмени
Підвищення ефективності тренувань, відстеження персонального прогресу та спортивних досягнень
Переважно позитивне, однак мають сумніви відносно точності вимірів фізичних показників та алгоритмів аналізу
Можливість отримання персональних рекомендацій за результатами тренувань та відстежувати результати в змаганнях
З'єднання з мережею Інтернет, наявність пристрою для вимірювання фізичних показників
Тренери
Підвищення результативності команди на змаганнях, відстеження стану здоров'я спортсменів
Переважно позитивно, однак мають сумніви відносно впровадження нових технологій у процес тренування
Відстеження результатів команди в змаганнях, підвищення організованості тренувального процесу 
З'єднання з мережею Інтернет


1.4.2	Пріоритети проекту


Таблиця 1.2 - Пріоритети проекту
Показник
Виконання
(етапи)
Обмеження
(граничні значення)
Ступінь свободи
(допустимий діапазон)
Терміни
Оптимальний термін випуску версії 1.0 програмної системи - до 08.06
Версію 1.0 програмної системи необхідно випустити до 15.06
Допускаються затримки у межах одного тижня
Функції
Базовий функціонал програми, визначений у пункті 3.1 “Рамки первинного випуску”, має бути реалізовано у версії 1.0 програмної системи
Відповідність усіх реалізованих функцій визначеним критеріям якості
Допускається перерозподіл ресурсів розробки для реалізації повного функціоналу версії 1.0 у зазначені терміни


Кінець таблиці 1.2
Показник
Виконання
(етапи)
Обмеження
(граничні значення)
Ступінь свободи
(допустимий діапазон)
Якість
Розроблена програмна система має стабільно працювати і проходити 98% тестів
Мінімальний допустимий відсоток пройдених тестів для випуску версії 1.0 програмної системи - 95%
Допускається перерозподіл ресурсів розробки для покращення стабільності роботи програмної системи
Персонал
Розмір команди - 1 розробник
Розширення команди максимум на 1-2 розробників
При збільшенні бюджету проекта можна найняти додаткових розробників
Ціна
Розробка в межах бюджету, виділеного керівництвом проекту 
На реалізацію базового функціонала програмної системи допустиме перевищення бюджету на 10%
Можливе розширення бюджету для реалізації додаткового функціонала


1.4.3	Робоче середовище


Серверна частина програмної системи буде розроблена в середовищі Visual Studio 2022 на мові програмування Python на платформі Django. Django є поширеним рішенням у розробці веб-додатків через гнучкість налаштування, продуктивність, можливість легко масштабувати додатки та наявність детальної документації.
Для розробки клієнтської частини використовуватимуться мова програмування JavaScript, мова розмітки HTML та мова стилів CSS, а також бібліотека React. Це популярне рішення для розробки веб-додатків у поєднанні з Django через компонентний підхід до розробки, сумісність з великою кількістю інших бібліотек і оптимізацію.
У якості СУБД для проекту було обрано Postgresql через можливість інтеграції з Django ORM, масштабованість, надійність і безпеку зберігання даних.
Для впровадження IoT-пристрою для виміру фізичних показників спортсменів буде використана мова програмування C++, платформа Arduino, емулятор Wokwi та середовище розробки Arduino IDE.
2 ПРОЕКТУВАННЯ ТА ПРОГРАМНА РЕАЛІЗАЦІЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	2.1	Проектування серверної частини програмної системи


Для реалізації функціоналу спроектованої програмної системи необхідно визначити і описати всі сутності системи. На основі визначених сутностей було створено ER-модель даних, яка візуалізує сутності та зв'язки між ними.
	Для моделі даних було визначено наступні сутності і поля:
	а) користувач:
1) користувач_id;
2) електронна_пошта;
3) пароль;
4) команда_id;
5) ім'я;
6) вік;
7) стать;
8) зріст;
9) вага;
10) роль;
б) команда:
1) команда_id;
2) назва;
3) місто;
4) вид спорту;
в) матч:
1) матч_id;
2) дата_і_час;
3) місце_проведення;
4) тривалість;
5) змагання_id;
г) матч_команда:
1) матч_команда_id;
2) матч_id;
3) команда_id;
4) рахунок_команди;
ґ) змагання:
1) змагання_id;
2) назва;
3) призовий_фонд;
4) ліга;
5) вид спорту;
д) тренування:
1) тренування_id;
2) дата_і_час;
3) місце_проведення;
4) тривалість;
е) користувач_тренування:
1) користувач_тренування_id;
2) користувач_id;
3) датчик_id;
4) тренування_id;
5) інтенсивність;
є) датчик:
1) датчик_id;
2) пульс.

	За допомогою наведених вище сутностей і полів буде реалізовано функціонал програмної системи, опис якого наведено в розділі 1. Для візуалізації структури даних на основі ER-моделі даних була побудована ER-модель даних (див. рис. 2.1).


Рисунок 2.1 - ER-модель даних

	Наступним етапом проектування серверної частини є визначення сценаріїв використання програмної системи. Функції системи розподілені між п’ятьма акторами: неавторизований користувач, спортсмен, тренер, адміністратор, датчик вимірювання пульсу. Розглянемо детальніше можливості, доступні кожному з них. 
Неавторизований користувач є користувачем, який не увійшов в систему. Йому доступні функції реєстрації та авторизації в системі.
Спортсмен має доступ до таких функцій, як перегляд матчів, перегляд змагань, отримання рекомендацій на майбутні тренування, які включають надсилання запитів на сервер та відстеження пульсу за допомогою датчика.
Тренер може управляти тренуваннями, створювати тренування та переглядати змагання.
Адміністратор має повний доступ до системи, включаючи адміністрування системи, створення записів, редагування існуючих записів, видалення записів, перегляд записів, резервне копіювання бази даних.
Датчик вимірювання пульсу відстежує пульс спортсмена та передає ці дані на сервер, де вони можуть бути використані для отримання рекомендацій на майбутні тренування.
На основі вищеописаних сценаріїв використання системи була створена UML діаграма прецедентів.


Рисунок 2.2 - UML діаграма прецедентів для серверної частини системи

	Отже, в результаті проектування серверної частини програмної системи були визначені та описані усі сутності системи, а також розроблено ER-модель даних та UML діаграму прецедентів.
	2.2	Інженерні рішення
	2.2.1	Використані технології


Рішення щодо вибору технологій для реалізації серверної частини програмної системи приймались відповідно до функціональних вимог проекту. З цією метою було обрано платформу Django на базі мови програмування Python, оскільки він забезпечує високу швидкість, безпеку та можливість масштабування, що важливо для проекту, орієнтованого на велику кількість користувачів. Для створення API в архітектурному стилі REST був використаний Django REST Framework.
Django REST Framework дозволяє створювати гнучкі та масштабовані веб-сервіси завдяки використанню унікальних ідентифікаторів URI для всіх ресурсів. Це забезпечує стандартизоване та надійне обслуговування запитів від клієнтської частини та інших компонентів системи.
Для управління базами даних у проекті була обрана PostgreSQL, яка забезпечує високу надійність, масштабованість та ефективність при роботі з великими обсягами даних. Взаємодія з базою даних здійснюється за допомогою власного ORM Django, що спрощує процес розробки та управління даними.
Взаємодія між серверною частиною, клієнтською частиною, мобільним застосунком та IoT-пристроями реалізована через REST API. Цей метод забезпечує єдину структуру для обміну інформацією та полегшує інтеграцію різних компонентів системи.
Детальний опис взаємодій серверної частини з іншими елементами системи наведено на UML діаграмі розгортання (див. рис. 2.3).


Рисунок 2.3 - UML діаграма розгортання

Для опису основних дій і етапів, через які проходить користувачі системи для досягнення своїх цілей, було розроблено UML діаграму діяльності (див. рис. Б.1, додаток Б). Вона ілюструє процес взаємодії між спортсменом, датчиком тренером та адміністратором для забезпечення ефективного тренувального процесу.


	2.2.2	Структура проекту


	Програмна система складається з компонентів, характерних для веб-сервісів, розроблених з використанням Django. Перелік цих компонентів подано нижче:
	а) Каталог SportManagerProject:
		1) файл manage.py, який використовується для запуску сервера та виконання адміністративних завдань;
		2) файл urls.py, в якому визначаються відповідності між URL-адресами та видами Django;
		3) файл settings.py, де зберігаються налаштування проекту;
	б) Каталог SportManagerApp:
		1) файл admin.py, який містить налаштування адміністративного інтерфейсу;
		2) файл models.py, в якому визначаються моделі проекту;
		3) файл forms.py, де визначаються форми для збору та обробки даних від користувачів;
		4) файл views.py, який містить види для обробки запитів;
		5) каталог templates, який містить шаблони сторінок веб-додатку.


	2.2.3	Реалізація REST API


	Взаємодія між серверною та клієнтською частинами програмної системи реалізована на основі принципів архітектурного стилю REST. Нижче наведено функції програмної системи, реалізовані таким чином (див. табл. 2.1).

Таблиця 2.1 - Специфікація REST API серверної частини програми
Сутність
Метод
Посилання
Опис функції
Загальні функції
POST
login/
Авторизація в системі
register/
Реєстрація в системі
GET
logout/
Вихід з акаунта


Продовження таблиці 2.1
Сутність
Метод
Посилання
Опис функції
Користувач
GET
users/
Виведення списку всіх користувачів 
users/<int:pk>/
Виведення деталей про обраного користувача
POST
users/new/
Створення нового користувача
users/<int:pk>/edit/
Редагування даних обраного користувача
DELETE
users/<int:pk>/delete/
Видалення обраного користувача
Команда
GET
teams/
Виведення списку всіх команд 
teams/<int:pk>/
Виведення деталей про обрану команду
POST
teams/new/
Створення нової команди
teams/<int:pk>/edit/
Редагування даних обраної команди
DELETE
teams/<int:pk>/delete/
Видалення обраної команди
Матч
GET
matches/
Виведення списку всіх матчів 
matches/<int:pk>/
Виведення деталей про обраний матч
POST
matches/new/
Створення нового матча
matches/<int:pk>/edit/
Редагування даних обраного матча
DELETE
matches/<int:pk>/delete/
Видалення обраного матча


Продовження таблиці 2.1

Сутність
Метод
Посилання
Опис функції
Змагання
GET
competitions/
Виведення списку всіх змагань 
competitions/<int:pk>/
Виведення деталей про обране змагання
POST
competitions/new/
Створення нового змагання
competitions/<int:pk>/edit/
Редагування даних обраного змагання
DELETE
competitions/<int:pk>/delete/
Видалення обраного змагання
Тренування
GET
trainings/
Виведення списку всіх тренувань 
trainings/<int:pk>/
Виведення деталей про обране тренування
POST
trainings/new/
Створення нового тренування
trainings/<int:pk>/edit/
Редагування даних обраного тренування
DELETE
trainings/<int:pk>/delete/
Видалення обраного тренування
Датчик
GET
sensors/
Виведення списку всіх датчиків 
sensors/<int:pk>/
Виведення деталей про обраний датчик
POST
sensors/new/
Створення нового датчика
sensors/<int:pk>/edit/
Редагування даних обраного датчика
DELETE
sensors/<int:pk>/delete/
Видалення обраного датчика


Продовження таблиці 2.1
Сутність
Метод
Посилання
Опис функції
Відносини користувач-
тренування
GET
user-trainings/
Виведення списку всіх відносин користувач-тренування 
user-trainings/<int:pk>/
Виведення деталей про обрані відносини користувач-тренування 
POST
user-trainings/new/
Створення нових відносин користувач-тренування 
user-trainings/<int:pk>/edit/
Редагування даних обраних відносин користувач-тренування 
DELETE
user-trainings/<int:pk>/delete/
Видалення обраних відносин користувач-тренування 
Відносини матч-команда
GET
match-teams/
Виведення списку всіх відносин матч-команда  
match-teams/<int:pk>/
Виведення деталей про обрані відносини матч-команда
POST
match-teams/new/
Створення нових відносин матч-команда
match-teams/<int:pk>/edit/
Редагування даних обраних відносин матч-команда
DELETE
match-teams/<int:pk>/delete/
Видалення обраних відносин матч-команда



	2.2.4 Опис реалізації функції для рекомендації режиму тренувань


	Основна функція, яку виконує метод generate_training_recommendation - створення рекомендацій для майбутніх тренувань спортсменів на основі навантажень, які вони отримували на попередніх тренуваннях, з метою збереження здоров’я спортсменів і їх продуктивності під час тренувань, що відповідає цілям проекту, тому ця функція є важливою складовою бізнес-логіки програмної системи.
	Виконання функції відбувається наступним чином: спочатку обчислюються межі мінімальної та максимальної інтенсивності для тренувань користувача на основі його віку (див. рядки 2-6, розділ А.1 додатку А). Далі виконується ітерація по тренуванням користувача для підрахунку кількості тренувань у помірних та високих межах інтенсивності (див. рядки 8-15, розділ А.1 додатку А). Після цього обчислюється загальна кількість тренувань користувача (див. рядки 17-24, розділ А.1 додатку А). Відбувається перевірка відношення кількості тренувань у помірному та високому інтенсивності до загальної кількості тренувань і формування рекомендації щодо інтенсивності тренувань користувача в залежності від цих відносин (див. рядки 26-30, розділ А.1 додатку А). Функція повертає рекомендацію, що відображає, як користувач може оптимізувати свій режим тренувань відповідно до інтенсивності (див. рядок 32, розділ А.1 додатку А).


2.2.5	Реалізація функції створення резервної копії бази даних


Створення резервних копій бази даних дозволяє захистити дані, необхідні для функціонування системи, від помилок при обробці, випадкового видалення, атак хакерів, а деякі регуляторні вимоги вимагають зберігання резервних копій для аудитів. Вищеназвані фактори дають вагому підставу вважати створення резервних копій важливою функцією програмної системи.
Виконання функції починається з отримання параметрів бази даних, таких як ім'я користувача, пароль, хост і порт (див. рядки 6-10, розділ А.2 додатку А). Далі створюється каталог для збереження резервних копій бази даних, якщо він ще не існує, і формується назва файлу резервної копії на основі поточної дати і часу (див. рядки 12-15, розділ А.2 додатку А). Після цього встановлюється пароль для з'єднання з базою даних (див. рядок 17, розділ А.2 додатку А). Наступним кроком є виклик утиліти pg_dump для створення резервної копії бази даних PostgreSQL за допомогою системного виклику (див. рядки 19-20, розділ А.2 додатку А). Після успішного виконання резервного копіювання виводиться повідомлення про успішне завершення операції разом з шляхом до створеної резервної копії (див. рядок 22, розділ А.2 додатку А).
3 ПРОЕКТУВАННЯ ТА ПРОГРАМНА РЕАЛІЗАЦІЯ IoT ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	3.1	Моделювання IoT-частини програмної системи


	Функціоналом IoT-частини програмної системи користуються як користувачі, так і датчик для вимірювання пульсу. Датчик вимірює поточне і середнє значення пульсу спортсмена, який носить його на зап'ясті, і надсилає отримані дані на сервер для подальшої обробки та зберігання. Для візуалізації вищеописаних взаємодій було створено діаграму прецедентів (див. рис. 3.1).


Рисунок 3.1 - UML діаграма прецедентів для IoT-частини системи

	Таким чином, в ході проектування IoT-частини програмної системи були визначені функціональні вимоги IoT-частини системи.
	3.2	Інженерні рішення
	3.2.1	Використані технології


	Для реалізації IoT-частини розроблюваної програмної системи використовується фоторезистор в емуляторі Wokwi для зчитування значень з аналогового датчика, що використовується для вимірювання пульсу через зміни освітленості. Програма підключається до Wi-Fi мережі за допомогою бібліотеки WiFi і використовує HTTPClient для взаємодії з сервером через протокол HTTP.
Дані про пульс обчислюються на основі змін освітленості, використовуючи алгоритм для визначення інтервалів між пульсами. Після обчислення, дані надсилаються на сервер за допомогою POST-запитів у форматі application/x-www-form-urlencoded, що дозволяє структуровано передавати дані про пульс на сервер для подальшого аналізу та обробки. 
Код оптимізовано для роботи на пристроях з обмеженою потужністю, забезпечуючи ефективне використання ресурсів пристрою та зручний обмін даними з сервером. Це підходить для впровадження на реальних IoT пристроях, де важливо ефективно взаємодіяти з серверними застосунками через мережу Wi-Fi.
Процес взаємодії IoT-пристрою з серверною частиною програмної системи ілюструє UML-діаграма діяльності (див. рис. 3.2).


Рисунок 3.2 - UML діаграма діяльності для IoT-частини програмної системи

	Отже, завдяки використаним технологіям, описаним в цьому розділі, відбувається передача даних про пульс спортсмена на сервер, де вони обробляються, зберігаються, а на їх основі формуються рекомендації до режиму майбутніх тренувань.


	3.2.2	Архітектурні рішення


	Технології, описані у попередньому пункті  (див. пункт 3.2.1), реалізовані за допомогою використання відповідних бібліотек. Програма компілюється в емуляторі мікроконтролерів Wokwi. Взаємодія пакетів у програмі та їх ієрархія зображені на діаграмі пакетів UML (див. рис. 3.3).


Рисунок 3.3 - UML діаграма пакетів для IoT-частини програмної системи

	Бібліотека HTTPClient.h використовується для здійснення HTTP-запитів (GET, POST та інші) до веб-серверів з метою обміну даними між IoT пристроєм та сервером. Вона забезпечує простий інтерфейс для надсилання та отримання даних через протокол HTTP, а бібліотека Wifi.h необхідна для підключення IoT-пристрою до Wi-Fi мережі.


	3.3	Взаємодії в системі


	Логіка високорівневих взаємодій в системі та їх етапи зображені на UML діаграмі взаємодії (див. рис. 3.4).


Рисунок 3.4 - UML діаграма взаємодії для IoT-частини програмної системи

	Створена UML діаграма взаємодій ілюструє основні етапи взаємодій між складовими частинами IoT-частини програмної системи.
4 ПРОЕКТУВАННЯ ТА ПРОГРАМНА РЕАЛІЗАЦІЯ КЛІЄНТСЬКОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	4.1	Структура клієнтської частини програмної системи


	Структуру клієнтської частини програмної системи ілюструє UML діаграма компонентів (див. рис. 4.1).


Рисунок 4.1 - UML діаграма компонентів клієнтської частини програмної системи

На діаграмі видно, що перехід на кожен з розділів додатку відбувається за допомогою навігаційної панелі, шаблон якої визначено в файлі base.html. До кожної зі сторінок приєднано файл CSS, який відповідає за стилізацію сторінок.
Крім того, в програмній реалізації клієнтської частини програмної системи задіяний скрипт на мові програмування JavaScript. Він зберігається у файлі convert_units.js і відповідає за конвертацію одиниць вимірювання росту й ваги спортсменів з метричної системи вимірювання в імперську і навпаки.
	4.2	Діяльність веб-клієнту програмної системи


	UML діаграма діяльності (див. рис. 4.2) ілюструє та описує можливі дії користувача при взаємодії з клієнтською частиною програмної системи. Вона містить ключові етапи навігації по сторінкам веб-додатку та дії, які доступні користувачу до виконання на них.


Рисунок 4.2 - UML діаграма діяльності для клієнтської частини системи


	4.3	Стани клієнтської частини програмної системи


	Для моделювання та візуалізації різних станів клієнтської частини програмної системи було розроблено UML діаграму станів (див. рис. 4.3).

Рисунок 4.3 - UML діаграма станів для клієнтської частини програмної системи


	4.4	Функція конвертації ваги та росту


	Для забезпечення можливості використання додатку користувачами з усього світу в клієнтській частині програмної системи було запроваджено можливість переведення одиниць виміру для відображення росту і ваги спортсменів з метричної системи вимірювання в імперську (див. додаток А.7). Ця додаткова функція дозволить значно розширити коло можливих користувачів і підвищити зручність використання, що позитивно впливає на репутацію програмної системи і на її конкурентоздатність.
ВИСНОВКИ


	Для виконання курсового проекту було проведено комплексне дослідження предметної області управління спортивними організаціями, яке включало в себе детальний аналіз ринку, бізнес-вимог та оцінку ризиків, окреслення концепції, визначення основного функціоналу проекта та його рамок,   виявлення зацікавлених сторін і створення плану розробки.
	На основі результатів дослідження була спроектована та розроблена програмна система для управління спортивними організаціями. Програмна система складається з серверної частини, реалізованої на платформі Django на базі мови програмування Python, клієнтської частини, реалізованої за допомогою HTML, CSS, JavaScript, а також IoT-пристрою, програмний код для якого було написано мовою програмування C++ з використанням емулятора Wokwi. Взаємодія між вищеописаними частинами програмної системи налагоджена за допомогою використання REST API, дані в системі зберігаються за допомогою СУБД Postgresql.
	Розроблена програмна система для управління спортивними організаціями дозволяє користувачам переглядати спортивні змагання, результати матчів, вимірювати пульс під час тренувань, отримувати рекомендації до навантаження на наступних тренуваннях на основі навантажень, отриманих на попередніх тренуваннях, переглядати календар з відмітками про майбутні тренування з можливістю створити нове тренування або відредагувати вже існуюче. Програма також підтримує інтернаціоналізацію, з метою цього було створено функцію конвертації одиниць вимірювання з метричної системи в імперську та навпаки.
	Таким чином, розроблена програмна система надає користувачам зручний інструмент для управління спортивними командами, організації тренувального процесу та спортивних заходів.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


Документація Django: https://docs.djangoproject.com/en/5.0/
Документація Python: https://docs.python.org/3/
Офіційний сайт Sportlyzer: https://www.sportlyzer.com/en/
Офіційний сайт TeamBuildr: https://www.teambuildr.com/
Github-репозиторій розробленої програмної системи: https://github.com/NureFursovVitalii/apzkr-pzpi-21-7-fursov-vitalii
Відеоролик з демонстрацією роботи і тестуванням розробленої програмної системи: https://youtu.be/rP02B_VsTOI


ДОДАТОК А
Програмний код

	А.1	Програмний код функції рекомендації інтенсивності тренувань:

1 def generate_training_recommendation(trainings, user):
2     mhr = 220 - user.age
3     moderate_min = 0.5 * mhr
4     moderate_max = 0.7 * mhr
5     high_min = 0.7 * mhr
6     high_max = 0.85 * mhr
7 
8     moderate_count = 0
9     high_count = 0
10 
11     for training in trainings:
12         if moderate_min <= training.intensity <=	 moderate_max:
13             moderate_count += 1
14         elif high_min <= training.intensity <= high_max:
15             high_count += 1
16 
17     total_trainings = len(trainings)
18 
19     if total_trainings == 0:
20         recommendation = "No recent training data available."
21     else:
22         moderate_ratio = moderate_count / total_trainings
23         high_ratio = high_count / total_trainings
24 
25         if moderate_ratio > 0.5:
26             recommendation = "You are doing a good amount of moderate intensity training. Keep it up!"
27         elif high_ratio > 0.5:
28             recommendation = "You are doing a lot of high intensity training. Consider incorporating more moderate intensity sessions."
29         else:
30             recommendation = "Your training intensity is well balanced. Continue with your current routine."
31 
32     return recommendation

	А.2	Програмний код функції створення резервної бази даних

1  class Command(BaseCommand):
2      help = 'Backup the PostgreSQL database'
3  
4      def handle(self, *args, **kwargs):
5          # Backup database
6          db_name = settings.DATABASES['default']['NAME']
7          db_user = settings.DATABASES['default']['USER']
8          db_password = settings.DATABASES['default']['PASSWORD']
9          db_host = settings.DATABASES['default']['HOST']
10         db_port = settings.DATABASES['default']['PORT']
11 
12         backup_dir = os.path.join(settings.BASE_DIR, 'backups')
13         os.makedirs(backup_dir, exist_ok=True)
14         date_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
15         db_backup_file = os.path.join(backup_dir, f'{db_name}_backup_{date_str}.sql')
16 
17         os.environ['PGPASSWORD'] = db_password
18         pg_dump_path = '/Library/PostgreSQL/16/bin/pg_dump'  
19         dump_cmd = f'{pg_dump_path} -U {db_user} -h {db_host} -p {db_port} {db_name} > {db_backup_file}'
20         os.system(dump_cmd)
21 
22         self.stdout.write(self.style.SUCCESS(f'Successfully backed up the database to {db_backup_file}'))



	А.3	Програмний код IoT-пристрою

1 #include <WiFi.h>
2 #include <HTTPClient.h>
3 
4 const char* ssid = "Wokwi-GUEST";
5 const char* password = "";
6 const char* server = "http://127.0.0.1:8000";  
7 
8 const char* sensor_update_endpoint = "/sensor_update/";  
9 const char* usertraining_update_endpoint = "/usertraining_update/";  
10 
11 const char* sensor_id = "1";
12 const char* user_id = "1";
13 
14 WiFiClient client;
15 HTTPClient http;
16 
17 const int ldrPin = 34;
18 int ldrValue;
19 bool pulseDetected = false;
20 unsigned long lastBeatTime = 0;
21 int beatInterval = 0;
22 int totalHeartRate = 0;
23 int numMeasurements = 0;
24 
25 void setup() {
26   Serial.begin(9600);
27   WiFi.begin(ssid, password);
28   while (WiFi.status() != WL_CONNECTED) {
29     delay(1000);
30   }
31 }
32 
33 void loop() {
34   ldrValue = analogRead(ldrPin);
35 
36   if (ldrValue < 500 && !pulseDetected) {
37     pulseDetected = true;
38     lastBeatTime = millis();
39   }
40 
41   if (ldrValue > 700 && pulseDetected) {
42     pulseDetected = false;
43     beatInterval = millis() - lastBeatTime;
44     int heartRate = 60000 / beatInterval;
45 
46     totalHeartRate += heartRate;
47     numMeasurements++;
48 
49     int averageHeartRate = totalHeartRate / numMeasurements;
50 
51     Serial.print("Current heart rate: ");
52     Serial.println(heartRate);
53     Serial.print("Average heart rate: ");
54     Serial.println(averageHeartRate);
55 
56     String sensor_update_url = String(server) + sensor_update_endpoint;
57     http.begin(client, sensor_update_url);
58     http.addHeader("Content-Type", "application/x-www-form-urlencoded");
59     String sensor_update_data = "sensor_id=" + String(sensor_id) + "&pulse=" + String(heartRate);
60     int sensor_update_response_code = http.POST(sensor_update_data);
61     if (sensor_update_response_code > 0) {
62       Serial.println("sensor_update request sent successfully");
63     } else {
64       Serial.print("Error sending sensor_update request: ");
65       Serial.println(sensor_update_response_code);
66     }
67     http.end();
68 
69     String usertraining_update_url = String(server) + usertraining_update_endpoint;
70     http.begin(client, usertraining_update_url);
71     http.addHeader("Content-Type", "application/x-www-form-urlencoded");
72     String usertraining_update_data = "user_id=" + String(user_id) + "&average_pulse=" + String(averageHeartRate);
73     int usertraining_update_response_code = http.POST(usertraining_update_data);
74     if (usertraining_update_response_code > 0) {
75       Serial.println("usertraining_update request sent successfully");
76     } else {
77       Serial.print("Error sending usertraining_update request: ");
78       Serial.println(usertraining_update_response_code);
79     }
80     http.end();
81   }
82 
83   delay(10);
84 }

	А.4	Програмний код сторінки реєстрації

1 <!DOCTYPE html>
2 <html lang="en">
3 <head>
4     <meta charset="UTF-8">
5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
6     <title>Register</title>
7     <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&display=swap" rel="stylesheet">
8     {% load static %}
9     <link rel="stylesheet" type="text/css" href="{% static 'SportManagerApp/styles/registration.css' %}">
10 </head>
11 <body>
12     <div class="credentials-box">
13         <h2>Register</h2>
14         <form method="post">
15             {% csrf_token %}
16             <div class="form-field">
17                 <label for="email">Email:</label>
18                 <input type="email" id="email" name="email" required>
19             </div>
20             <div class="form-field">
21                 <label for="first_name">First Name:</label>
22                 <input type="text" id="first_name" name="first_name" required>
23             </div>
24             <div class="form-field">
25                 <label for="age">Age:</label>
26                 <input type="number" id="age" name="age" required>
27             </div>
28             <div class="form-field radio-buttons">
29                 <label for="gender">Gender:</label>
30                 <label><input type="radio" id="male" name="gender" value="male" required> Male</label>
31                 <label><input type="radio" id="female" name="gender" value="female" required> Female</label>
32             </div>
33             <div class="form-field">
34                 <label for="height">Height (cm):</label>
35                 <input type="number" id="height" name="height" required>
36             </div>
37             <div class="form-field">
38                 <label for="weight">Weight (kg):</label>
39                 <input type="number" id="weight" name="weight" required>
40             </div>
41             <div class="form-field">
42                 <label for="password1">Password:</label>
43                 <input type="password" id="password1" name="password1" required>
44             </div>
45             <div class="form-field">
46                 <label for="password2">Confirm Password:</label>
47                 <input type="password" id="password2" name="password2" required>
48             </div>
49             <button type="submit">Register</button>
50         </form>
51         <a href="{% url 'login' %}" class="login-link">Sign in</a>
52         {% if form.errors %}
53             <ul class="error-list">
54                 {% for field in form %}
55                     {% for error in field.errors %}
56                         <li>{{ error }}</li>
57                     {% endfor %}
58                 {% endfor %}
59                 {% for error in form.non_field_errors %}
60                     <li>{{ error }}</li>
61                 {% endfor %}
62             </ul>
63         {% endif %}
64     </div>
65 </body>
66 </html>

	А.5	Програмний код сторінки авторизації

1 <!DOCTYPE html>
2 <html lang="en">
3 <head>
4     <meta charset="UTF-8">
5     <title>Login</title>
6     <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&display=swap" rel="stylesheet">
7     {% load static %}
8     <link rel="stylesheet" type="text/css" href="{% static 'SportManagerApp/styles/login.css' %}">
9 </head>
10 <body>
11     <div class="credentials-box">
12         <h2>Login</h2>
13     <form method="post" action="{% url 'login' %}">
14         {% csrf_token %}
15         <div class="email-field">
16             <label for="username">Email:</label>
17             <input type="text" id="username" name="username" required>
18         </div>
19         <div class="password-field">
20             <label for="password">Password:</label>
21             <input type="password" id="password" name="password" required>
22         </div>
23         <button type="submit">Log in</button>
24     </form>
25     <a href="{% url 'register' %}" class="registration-link">Create an account</a>
26     {% if form.errors %}
27         <ul>
28             {% for field in form %}
29                 {% for error in field.errors %}
30                     <li>{{ error }}</li>
31                 {% endfor %}
32             {% endfor %}
33             {% for error in form.non_field_errors %}
34                 <li>{{ error }}</li>
35             {% endfor %}
36         </ul>
37     {% endif %}
38     </div>
39 </body>
40 </html>

	А.6	Програмний код сторінки календаря

1 {% extends 'SportManagerApp/base.html' %}
2 
3 {% load static %}
4 
5 {% block content %}
6 <head>
7     <link rel="stylesheet" type="text/css" href="{% static 'SportManagerApp/styles/training_list.css' %}">
8 </head>
9 <div class="container">
10     <div class="calendar-header">
11         
12         <h2><a href="{% url 'training_list' previous_month.year previous_month.month %}" class="nav-button">&laquo; Previous </a>{{ current_month }} {{ current_year }}<a href="{% url 'training_list' next_month.year next_month.month %}" class="nav-button"> Next &raquo;</a></h2>
13         
14     </div>
15     <div class="calendar">
16         {% for day in days_in_calendar %}
17             <div class="day {% if day.trainings %}training-day{% endif %}">
18                 <div class="date">{{ day.date|date:"j" }}</div>
19                 <div class="trainings">
20                     {% for training in day.trainings %}
21                         <div class="training">
22                             <a href="{% url 'training_detail' training.pk %}">{{ training.location }}</a>
23                             {% if user.is_authenticated %}
24                                 {% if user.role == 'admin' or user.role == 'coach' %}
25                                     <a href="{% url 'training_update' training.pk %}" class="edit-button">Edit</a>
26                                     <form method="post" action="{% url 'training_delete' training.pk %}" style="display:inline;">
27                                         {% csrf_token %}
28                                         <button type="submit" class="delete-button">Delete</button>
29                                     </form>
30                                 {% endif %}
31                             {% endif %}
32                         </div>
33                     {% endfor %}
34                     {% if not day.trainings %}
35                         {% if user.is_authenticated %}
36                             {% if user.role == 'admin' or user.role == 'coach' %}
37                                 <a href="{% url 'training_create' day.date|date:'Y-m-d' %}" class="add-button">Add Training</a>
38                             {% endif %}
39                         {% endif %}
40                     {% endif %}
41                 </div>
42             </div>
43         {% endfor %}
44     </div>
45 </div>
46 {% endblock %}

	А.7	Програмний код функції конвертації одиниць обчислення

1 var isImperial = false;
2 
3 function toggleUnits() {
4     var heightElement = document.getElementById("height");
5     var weightElement = document.getElementById("weight");
6     var heightUnitElement = document.getElementById("height-unit");
7     var weightUnitElement = document.getElementById("weight-unit");
8     var toggleButton = document.getElementById("toggleButton");
9 
10     if (isImperial) {
11         var originalHeight = parseFloat(heightElement.getAttribute('data-original-height'));
12         var originalWeight = parseFloat(weightElement.getAttribute('data-original-weight'));
13 
14         heightElement.innerText = originalHeight;
15         weightElement.innerText = originalWeight;
16         heightUnitElement.innerText = 'cm';
17         weightUnitElement.innerText = 'kg';
18         toggleButton.innerText = 'Toggle to Imperial Units';
19     } else {
20         var originalHeight = parseFloat(heightElement.innerText);
21         var originalWeight = parseFloat(weightElement.innerText);
22 
23         var heightInInches = originalHeight / 2.54;
24         var feet = Math.floor(heightInInches / 12);
25         var inches = Math.round(heightInInches % 12);
26         var weightInPounds = originalWeight * 2.20462;
27 
28         heightElement.innerText = `${feet} ft ${inches} in`;
29         weightElement.innerText = weightInPounds.toFixed(2);
30         heightUnitElement.innerText = '';
31         weightUnitElement.innerText = 'lb';
32         toggleButton.innerText = 'Toggle to Metric Units';
33     }
34 
35     isImperial = !isImperial;
36 }

А.8 - Функція підрахунку статистики команд

1  # Statistics of the team
2  def team_statistics(team_id):
3      # 1. Number of competitions the team participated in
4      competitions_count = MatchTeam.objects.filter(team_id=team_id).values('match__competition').distinct().count()
5 
6      # 2. The most successful competition
7      competition_scores = (
8          MatchTeam.objects.filter(team_id=team_id)
9          .values('match__competition__name')
10         .annotate(total_score=Sum('team_score'))
11         .order_by('-total_score')
12     )
13     most_successful_competition = competition_scores[0]['match__competition__name'] if competition_scores else None
14     most_successful_competition_score = competition_scores[0]['total_score'] if competition_scores else 0
15 
16     # 3. Average age of team members
17     average_age = User.objects.filter(team_id=team_id).aggregate(Avg('age'))['age__avg']
18 
19     # 4. Team's win percentage
20     total_matches = MatchTeam.objects.filter(team_id=team_id).count()
21     won_matches = MatchTeam.objects.filter(
22         team_id=team_id,
23         team_score__gt=F('match__matchteam__team_score')
24     ).count()
25     win_percentage = (won_matches / total_matches * 100) if total_matches > 0 else 0
26 
27     # 5. Average goals (or points) per match
28     average_goals_per_match = MatchTeam.objects.filter(team_id=team_id).aggregate(Avg('team_score'))['team_score__avg']
29     
30     return {
31         'competitions_count': competitions_count,
32         'most_successful_competition': most_successful_competition,
33         'most_successful_competition_score': most_successful_competition_score,
34         'average_age': average_age,
35         'win_percentage': win_percentage,
36         'average_goals_per_match': average_goals_per_match,
37     }
ДОДАТОК Б
UML-діаграма діяльності


Рисунок Б.1 - UML-діаграма діяльності серверної частини програмної системи
